I am developing a simple mobile app using Native Expo React. It is a location sharing app where users can view and share live location. Here is the full project:

App.js
```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { useEffect, useState, useRef, createContext, useContext } from 'react';
import { View, Text, TouchableOpacity, TextInput, SafeAreaView, StatusBar, ActivityIndicator, ScrollView, KeyboardAvoidingView, Keyboard, TouchableWithoutFeedback, Platform, Modal, Pressable } from 'react-native';
import { Avatar, Button, Icon, SearchBar, Chip, ListItem } from '@rneui/themed';
import MapView, { Marker, AnimatedRegion, PROVIDER_GOOGLE, Callout } from 'react-native-maps';
import * as Location from 'expo-location';
import 'react-native-get-random-values';
import { initializeApp } from 'firebase/app';
import { getDatabase, ref, onValue, set, update, remove } from 'firebase/database';
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import { NavigationContainer, useNavigationState } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import ViewPager from '@react-native-community/viewpager';
import * as Linking from 'expo-linking';
import * as Haptics from 'expo-haptics';
import * as Clipboard from 'expo-clipboard';
import * as TaskManager from 'expo-task-manager';
import debounce from 'lodash.debounce';
// import * as BackgroundFetch from 'expo-background-fetch';
import * as Notifications from 'expo-notifications';
import { generateUsername } from './generateUsername';
import { customMapStyle, styles } from './Styles';
import { firebaseConfig } from './firebaseConfig';

const app = initializeApp(firebaseConfig);
const database = getDatabase(app);

const UsersContext = createContext();

export const LOCATION_TASK_NAME = 'background-location-task';

const debouncedUpdateUserLocation = debounce(async (userRef, coords) => {
  console.log(`Debounced location update`);
  await update(userRef, {
    location: coords,
    timestamp: Date.now(),
  });
}, 4000);

TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error(error);
    return;
  }
  if (data) {
    console.log(`Updating location through background`);
    const { locations } = data;
    const database = getDatabase();
    const userId = await AsyncStorage.getItem('userId');
    const userName = await AsyncStorage.getItem('userName');
    if (userId && userName && locations && locations.length > 0) {
      const { coords } = locations[0];
      const userRef = ref(database, `users/${userId}`);
      await update(userRef, {
        location: coords,
        timestamp: Date.now(),
      });
    }
  }
});

export const startLocationTracking = async () => {
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus !== 'granted') {
    console.error('Foreground location permission is required');
    return;
  }

  const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
  if (backgroundStatus !== 'granted') {
    console.error('Background location permission is required');
    return;
  }

  console.log('Location permissions granted');

  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.Highest,
    timeInterval: 60000, // 60 seconds
    distanceInterval: 0, // Receive updates based on time interval
    foregroundService: {
      notificationTitle: "Location tracking",
      notificationBody: "Location tracking is running",
      notificationColor: "#00ADB5",
    },
    pausesUpdatesAutomatically: false, // Keep updates running even if the app is paused
    activityType: Location.ActivityType.OtherNavigation,
    showsBackgroundLocationIndicator: true,
  });
};

const useUsers = () => {
  const context = useContext(UsersContext);
  if (!context) {
    throw new Error('useUsers must be used within a UsersProvider');
  }
  return context;
};

const UsersProvider = ({ children }) => {
  const [users, setUsers] = useState({});
  const [currentUserId, setCurrentUserId] = useState('');
  const [currentUserName, setCurrentUserName] = useState('');

  useEffect(() => {
    const fetchUsers = () => {
      const usersRef = ref(database, 'users');
      onValue(usersRef, (snapshot) => {
        setUsers(snapshot.val() || {});
      });
    };

    const fetchCurrentUser = async () => {
      const userId = await AsyncStorage.getItem('userId');
      const userName = await AsyncStorage.getItem('userName');
      if (userId && userName) {
        setCurrentUserId(userId);
        setCurrentUserName(userName);
      }
    };

    fetchUsers();
    fetchCurrentUser();
  }, []);

  const updateUser = (userId, data) => {
    const userRef = ref(database, `users/${userId}`);
    console.log(data);
    update(userRef, data);
  };

  const value = {
    users,
    currentUserId,
    currentUserName,
    setCurrentUserId,
    setCurrentUserName,
    updateUser,
  };

  return <UsersContext.Provider value={value}>{children}</UsersContext.Provider>;
};

const generateUuid = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (Math.random() * 16) | 0,
      v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

const generateUuidAndSave = async () => {
  const existingUuid = await AsyncStorage.getItem('userId');
  if (!existingUuid) {
    const uuid = generateUuid();
    await AsyncStorage.setItem('userId', uuid);
    return uuid;
  }
  return existingUuid;
};

const Tab = createBottomTabNavigator();

const Header = () => {
  return (
    <SafeAreaView style={styles.headerContainer}></SafeAreaView>
  );
};

const UserAvatarMarker = ({ user, size, color }) => {
  const getTwoFirstLetters = (name) => {
    if (!name) {
      return 'NA';
    }
    return name.substring(0, 2).toUpperCase();
  };

  if (!user) {
    return null;
  }

  return (
    <Avatar
      size={size || 30}
      rounded
      title={getTwoFirstLetters(user.name || 'NA')}
      containerStyle={{ backgroundColor: color || '#FFFFFF' }}
      titleStyle={{ color: 'black' }}
      source={{ uri: "data:image/png" }}
    />
  );
};

// Haversine formula
const getDistanceFromLatLonInKm = (lat1, lon1, lat2, lon2) => {
  if (!lat1 || !lon1 || !lat2 || !lon2) {
    return Infinity;
  }
  const R = 6371;
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
};

const deg2rad = (deg) => {
  return deg * (Math.PI / 180);
};

const formatTimeAgo = (timestamp) => {
  const now = Date.now();
  const diff = now - timestamp;

  const seconds = Math.floor(diff / 1000);
  if (seconds < 60) return `${seconds} seconds ago`;

  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minutes ago`;

  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hours ago`;

  const days = Math.floor(hours / 24);
  return `${days} days ago`;
};

const OnboardingScreen = ({ onFinish }) => {
  const pagerRef = useRef(null);
  const [username, setUsername] = useState(generateUsername('-', 3));

  const finishSetup = async () => {
    const userId = await generateUuidAndSave();
    await AsyncStorage.setItem('userName', username);
    await set(ref(database, `users/${userId}`), {
      id: userId,
      name: username,
      location: null,
      timestamp: Date.now(),
      friends: {},
      requests: {}
    });
    onFinish(username, userId);
  };

  return (
    <ViewPager style={{ flex: 1 }} ref={pagerRef}>
      <View key="1" style={styles.onboardingPage}>
        <Text style={styles.onboardingTitle}>Welcome to Loco</Text>
        <FontAwesome6 name="earth-americas" size={100} color="white" />
        <TouchableOpacity onPress={() => pagerRef.current.setPage(1)} style={styles.onboardingButton}>
          <Text style={styles.onboardingButtonText}>Next</Text>
        </TouchableOpacity>
      </View>
      <KeyboardAvoidingView style={{ flex: 1 }} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
        <View key="2" style={styles.onboardingPage}>
          <Text style={styles.onboardingTitle}>Choose Your Name</Text>
          <TextInput
            style={styles.onboardingInput}
            onChangeText={setUsername}
            value={username}
            placeholder="Enter your username"
            placeholderTextColor="#CCCCCC"
          />
          <TouchableOpacity onPress={() => pagerRef.current.setPage(2)} style={styles.onboardingButton}>
            <Text style={styles.onboardingButtonText}>Save</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
      <View key="3" style={styles.onboardingPage}>
        <Text style={styles.onboardingTitle}>Let's Get Started</Text>
        <FontAwesome6 name="globe" size={100} color="white" />
        <TouchableOpacity onPress={finishSetup} style={styles.onboardingButton}>
          <Text style={styles.onboardingButtonText}>Finish Setup</Text>
        </TouchableOpacity>
      </View>
    </ViewPager>
  );
};

const UserDialog = ({ isVisible, onClose, user }) => {
  const { currentUserId, users, updateUser } = useUsers();
  if (!user) return null;

  const isCurrentUser = user.id === currentUserId;
  const isFriend = users[currentUserId]?.friends?.[user.id];
  const hasSentRequest = users[user.id]?.requests?.[currentUserId];

  const handleFriendButtonPress = async () => {
    if (isFriend) {
      await removeFriend(user.id);
    } else {
      await toggleFriendRequest(user.id);
    }
    // close on Friend page, not on Map page
    onClose();
  };

  const handleCopyAddress = () => {
    console.log("Copy address pressed");
  };

  const handleCopyCoordinates = () => {
    console.log("Copy coordinates pressed");
    Clipboard.setStringAsync(`${user.location.latitude}, ${user.location.longitude}`);
  };

  const handleSetDirections = () => {
    if (user.location) {
      const url = `http://maps.google.com/?q=${user.location.latitude},${user.location.longitude}`;
      Linking.openURL(url);
    } else {
      console.log("User location is not available.");
    }
  };

  const removeFriend = async (friendId) => {
    if (!currentUserId) {
      console.log('User ID is not set');
      return;
    }

    const currentUserRef = ref(database, `users/${currentUserId}`);
    const friendUserRef = ref(database, `users/${friendId}`);

    await update(currentUserRef, {
      [`friends/${friendId}`]: null,
    });
    await update(friendUserRef, {
      [`friends/${currentUserId}`]: null,
    });

    console.log(`Removed friend ${friendId}`);
  };

  const toggleFriendRequest = async (receiverId) => {
    if (!currentUserId) {
      console.log('User ID is not set');
      return;
    }

    const requestsRef = ref(database, `users/${receiverId}/requests/${currentUserId}`);
    onValue(requestsRef, async (snapshot) => {
      if (snapshot.exists()) {
        await set(requestsRef, null);
        console.log('Friend request removed.');
      } else {
        await set(requestsRef, true);
        console.log('Friend request sent!');
      }
    }, {
      onlyOnce: true,
    });
  };

  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={isVisible}
      onRequestClose={onClose}
      onDismiss={onClose}
    >
      <Pressable style={styles.centeredView} onPress={onClose}>
        <View style={styles.modalView}>
          <Text style={styles.modalText}>{!isCurrentUser ? user.name : "You"}</Text>
          {!isCurrentUser && (
            <>
              <Button
                title={isFriend ? "Remove friend" : hasSentRequest ? "Cancel friend request" : "Send friend request"}
                onPress={handleFriendButtonPress}
                buttonStyle={styles.dialogButton}
                titleStyle={styles.dialogButtonTitle}
              />
            </>
          )}
          <Button
            title="Copy address"
            onPress={handleCopyAddress}
            buttonStyle={styles.dialogButton}
            titleStyle={styles.dialogButtonTitle}
          />
          <Button
            title="Copy coordinates"
            onPress={handleCopyCoordinates}
            buttonStyle={styles.dialogButton}
            titleStyle={styles.dialogButtonTitle}
          />
          {!isCurrentUser && (
            <>
              <Button
                title="Set directions"
                onPress={handleSetDirections}
                buttonStyle={styles.dialogButton}
                titleStyle={styles.dialogButtonTitle}
              />
            </>
          )}
        </View>
      </Pressable>
    </Modal>
  );
};

const MapScreen = ({ searchBarRef }) => {
  const mapRef = useRef(null);
  const [location, setLocation] = useState(null);
  const [initialRegionSet, setInitialRegionSet] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchActive, setSearchActive] = useState(false);
  const [dialogVisible, setDialogVisible] = useState(false);
  const [dialogUser, setDialogUser] = useState(null);
  const [filter, setFilter] = useState('All');

  const { users, currentUserId, currentUserName, updateUser } = useUsers();

  const sortedUsers = React.useMemo(() => {
    const query = searchQuery.toLowerCase();
    return Object.entries(users)
      .map(([id, user]) => ({
        id,
        ...user,
        distance: location ? getDistanceFromLatLonInKm(
          location.latitude,
          location.longitude,
          user.location?.latitude,
          user.location?.longitude
        ) : Infinity,
      }))
      .filter(user => user.id !== currentUserId && user.name.toLowerCase().includes(query))
      .sort((a, b) => a.distance - b.distance);
  }, [users, location, currentUserId, searchQuery, filter]);

  useEffect(() => {
    const initLocationTracking = async () => {
      let { status: foreStatus } = await Location.requestForegroundPermissionsAsync();
      let { status: backStatus } = await Location.requestBackgroundPermissionsAsync();
      if (foreStatus !== 'granted' || backStatus !== 'granted') {
        console.error('Permission to access location was denied');
        return;
      }
  
      let currentLocation = await Location.getCurrentPositionAsync({});
      if (currentLocation && currentLocation.coords) {
        setLocation(currentLocation.coords);
        setInitialRegionSet(true);
  
        // Update local location state every 60 seconds
        Location.watchPositionAsync({
          accuracy: Location.Accuracy.Balanced,
          timeInterval: 60000, // 60 seconds
          distanceInterval: 0,
        }, (newLocation) => {
          setLocation(newLocation.coords);
        }).then((watcher) => {
          return () => watcher.remove();
        });
      }
    };
  
    initLocationTracking();
  }, [currentUserId, currentUserName]);  

  const handleSearch = (query) => {
    setSearchQuery(query);
  };

  const handleMapAllPress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setFilter('All');
  };

  const handleMapFriendsPress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setFilter(filter === 'Friends' ? 'All' : 'Friends');
  };

  const handleCalloutPress = (user) => {
    console.log('Callout pressed:', user.name);
    setDialogUser(user);
    setDialogVisible(true);
  };

  const renderCalloutContent = (user) => {
    if (!user || !user.location || !user.location.latitude || !user.location.longitude) {
      return null;
    }

    const isCurrentUser = user.id === currentUserId;
    const distance = location && user.location
      ? getDistanceFromLatLonInKm(
        location.latitude,
        location.longitude,
        user.location.latitude,
        user.location.longitude
      ).toFixed(2)
      : 'Unknown';
    const timeAgo = user.timestamp ? formatTimeAgo(user.timestamp) : 'Unknown';

    return (
      <Callout onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); handleCalloutPress(user); }} >
        <View style={[styles.card]}>
          <Avatar
            size={25}
            rounded
            title={user.name.substring(0, 2).toUpperCase()}
            containerStyle={styles.avatar}
            source={{ uri: "data:image/png" }}
          />
          <View style={styles.info}>
            <Text style={styles.name}>{user.name}</Text>
            {!isCurrentUser && (
              <>
                <Text style={styles.details}>{distance} km away</Text>
                <Text style={styles.details}>{timeAgo}</Text>
              </>
            )}
          </View>
          <View style={styles.userOptions}>
            <Icon name="dots-three-vertical" type="entypo" color="black" size={20} />
          </View>
        </View>
      </Callout>
    );
  };

  const toggleFriendRequest = async (receiverId) => {
    if (!currentUserId) {
      console.log('User ID is not set');
      return;
    }

    const requestsRef = ref(database, `users/${receiverId}/requests/${currentUserId}`);
    onValue(requestsRef, async (snapshot) => {
      if (snapshot.exists()) {
        await set(requestsRef, null);
        console.log('Friend request removed.');
      } else {
        await set(requestsRef, true);
        console.log('Friend request sent!');
      }
    }, {
      onlyOnce: true,
    });
  };

  const removeFriend = async (friendId) => {
    if (!currentUserId) {
      console.log('User ID is not set');
      return;
    }

    const currentUserRef = ref(database, `users/${currentUserId}`);
    const friendUserRef = ref(database, `users/${friendId}`);

    await update(currentUserRef, {
      [`friends/${friendId}`]: null,
    });
    await update(friendUserRef, {
      [`friends/${currentUserId}`]: null,
    });

    console.log(`Removed friend ${friendId}`);
  };

  const recenterMap = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    if (location && mapRef.current) {
      mapRef.current.animateToRegion({
        latitude: location.latitude,
        longitude: location.longitude,
        latitudeDelta: 0.0922,
        longitudeDelta: 0.0421,
      }, 500);
    }
  };

  const zoomToUserLocation = (location, isFriend) => {
    setSearchQuery('');
    setSearchActive(false);
    Keyboard.dismiss();
    if (!isFriend) {
      setFilter('All');
    }
    if (mapRef.current && location) {
      mapRef.current.animateToRegion({
        latitude: location.latitude,
        longitude: location.longitude,
        latitudeDelta: 0.005,
        longitudeDelta: 0.005,
      }, 1000);
    }
  };

  const closeSearch = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    searchBarRef.current.blur();
    setSearchActive(false);
    setSearchQuery('');
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <KeyboardAvoidingView style={{ flex: 1 }} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
        <View style={{ flex: 1 }}>
          <Header />
          <View style={styles.filterContainer}>
            {searchActive && (
              <Button
                type="solid"
                icon={{
                  name: 'chevron-left',
                  type: 'font-awesome',
                  size: 20,
                  color: 'black',
                }}
                onPress={closeSearch}
                buttonStyle={styles.closeButtonStyle}
                containerStyle={styles.closeButtonContainer}
              />
            )}
            <SearchBar
              platform="default"
              placeholder="Search for users..."
              onChangeText={handleSearch}
              value={searchQuery}
              onFocus={() => { setSearchActive(true); Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) }}
              ref={searchBarRef}
              containerStyle={[
                styles.searchContainerStyle,
                { marginLeft: searchActive ? 60 : 0, flex: searchActive ? 1 : 0 },
              ]}
              inputContainerStyle={styles.searchInputContainerStyle}
              inputStyle={styles.searchInputStyle}
              round
            />
            <View style={styles.chipsContainer}>
              <Chip
                title="All"
                icon={{
                  name: 'globe',
                  type: 'font-awesome',
                  size: 17,
                }}
                titleStyle={{ color: 'black' }}
                onPress={handleMapAllPress}
                type="solid"
                containerStyle={styles.chipContainerStyle}
                buttonStyle={[styles.chipStyle, filter === 'All' && styles.selectedChipStyle]}
              />
              <Chip
                title="Friends"
                icon={{
                  name: 'users',
                  type: 'font-awesome',
                  size: 17,
                }}
                titleStyle={{ color: 'black' }}
                onPress={handleMapFriendsPress}
                type="solid"
                containerStyle={styles.chipContainerStyle}
                buttonStyle={[styles.chipStyle, filter === 'Friends' && styles.selectedChipStyle]}
              />
            </View>
          </View>
          {(searchActive || searchQuery) && (
            <View style={styles.searchResultsContainer}>
              {sortedUsers.length === 0 ? (
                <View style={styles.noUserFoundContainer}>
                  <Text style={styles.noUserFoundText}>No user found</Text>
                </View>
              ) : (
                <ScrollView keyboardShouldPersistTaps='handled'>
                  {sortedUsers.map((user) => {
                    const isFriend = users[currentUserId]?.friends?.[user.id];
                    return (
                      <ListItem
                        key={user.id}
                        bottomDivider
                        onPress={() => zoomToUserLocation(user.location, isFriend)}
                      >
                        <UserAvatarMarker user={user} size={30} color="#00ADB5" />
                        <ListItem.Content>
                          <ListItem.Title>{user.name}</ListItem.Title>
                          <ListItem.Subtitle>{user.distance.toFixed(2)} km away</ListItem.Subtitle>
                        </ListItem.Content>
                        <Button
                          type="clear"
                          icon={{
                            name: isFriend ? 'user-times' : user.requests && user.requests[currentUserId] ? 'check' : 'user-plus',
                            type: 'font-awesome',
                            size: 25,
                            color: isFriend ? 'red' : user.requests && user.requests[currentUserId] ? 'green' : '#222831',
                          }}
                          onPress={() => isFriend ? removeFriend(user.id) : toggleFriendRequest(user.id)}
                        />
                      </ListItem>
                    );
                  })}
                </ScrollView>
              )}
            </View>
          )}
          <MapView
            ref={mapRef}
            provider={PROVIDER_GOOGLE}
            style={styles.map}
            initialRegion={location ? {
              latitude: location.latitude,
              longitude: location.longitude,
              latitudeDelta: 0.0922,
              longitudeDelta: 0.0421,
            } : undefined}
            onMapReady={() => {
              if (location && !initialRegionSet) {
                setInitialRegionSet(true);
                mapRef.current.animateToRegion({
                  latitude: location.latitude,
                  longitude: location.longitude,
                  latitudeDelta: 0.0922,
                  longitudeDelta: 0.0421,
                }, 500);
              };
            }}
            onRegionChange={() => {
            }}
            customMapStyle={customMapStyle}
          >
            {location && location.latitude && location.longitude && (
              <Marker.Animated
                key={currentUserId}
                anchor={{ x: 0.5, y: 0.5 }}
                coordinate={new AnimatedRegion({
                  latitude: location.latitude,
                  longitude: location.longitude,
                  latitudeDelta: 0.0922,
                  longitudeDelta: 0.0421,
                })}
                title="You"
              >
                <UserAvatarMarker user={{ name: currentUserName || 'NA' }} color="#00ADB5" />
                {renderCalloutContent({ id: currentUserId, name: currentUserName, location })}
              </Marker.Animated>
            )}
            {Object.entries(users)
              .filter(([id, user]) =>
                id !== currentUserId &&
                user &&
                user.location &&
                user.location.latitude &&
                user.location.longitude &&
                (filter === 'All' || (filter === 'Friends' && users[currentUserId]?.friends?.[id]))
              )
              .map(([id, user]) => (
                <Marker.Animated
                  key={id}
                  anchor={{ x: 0.5, y: 0.5 }}
                  coordinate={new AnimatedRegion({
                    latitude: user.location.latitude,
                    longitude: user.location.longitude,
                    latitudeDelta: 0.0922,
                    longitudeDelta: 0.0421,
                  })}
                  title={user.name || 'Anonymous'}
                >
                  <UserAvatarMarker user={{ name: user.name || 'NA' }} />
                  {renderCalloutContent(user)}
                </Marker.Animated>
              ))
            }
          </MapView>
          <Button
            buttonStyle={[styles.recenterButton, null]}
            containerStyle={styles.recenterButtonContainer}
            icon={
              <Icon
                name="location-arrow"
                type="font-awesome"
                size={25}
                color={'#00ADB5'}
              />
            }
            onPress={() => recenterMap()}
          />
        </View>
        <UserDialog
          isVisible={dialogVisible}
          onClose={() => setDialogVisible(false)}
          user={dialogUser}
        />
      </KeyboardAvoidingView>
    </TouchableWithoutFeedback>
  );
};

const FriendsScreen = ({ navigation, focusSearchBar }) => {
  const { users, currentUserId, updateUser } = useUsers();
  const [dialogVisible, setDialogVisible] = useState(false);
  const [dialogUser, setDialogUser] = useState(null);

  const acceptFriendRequest = async (friendId) => {
    const currentUserRef = ref(database, `users/${currentUserId}`);
    const friendUserRef = ref(database, `users/${friendId}`);

    await update(currentUserRef, {
      [`friends/${friendId}`]: true,
    });
    await update(friendUserRef, {
      [`friends/${currentUserId}`]: true,
    });

    await update(currentUserRef, {
      [`requests/${friendId}`]: null,
    });
    await update(friendUserRef, {
      [`requests/${currentUserId}`]: null,
    });

    console.log(`Accepted friend request from ${friendId}`);
  };

  const rejectFriendRequest = async (friendId) => {
    const currentUserRef = ref(database, `users/${currentUserId}`);
    await update(currentUserRef, {
      [`requests/${friendId}`]: null,
    });

    console.log(`Rejected friend request from ${friendId}`);
  };

  const cancelPendingRequest = async (receiverId) => {
    const receiverRef = ref(database, `users/${receiverId}/requests/${currentUserId}`);
    await remove(receiverRef);
    console.log(`Cancelled pending request to ${receiverId}`);
  };

  const FriendRequestCard = ({ username, onAccept, onReject }) => (
    <View style={styles.friendRequestCard}>
      <View style={styles.friendRequestHeader}>
        <Icon
          name="bell-ring-outline"
          type="material-community"
          color="white"
          size={27}
          containerStyle={styles.friendRequestIcon}
        />
        <Text style={styles.friendRequestUsernameText}>{username}</Text><Text style={styles.friendRequestText}> asked to be your friend!</Text>
      </View>
      <View style={styles.friendRequestActions}>
        <Button
          type="outline"
          title="Hel yeah!"
          icon={{
            name: 'check',
            type: 'font-awesome',
            color: 'green',
          }}
          titleStyle={{ color: 'white' }}
          buttonStyle={styles.acceptButton}
          onPress={onAccept}
        />
        <Button
          type="outline"
          title="Eww no..."
          icon={{
            name: 'times',
            type: 'font-awesome',
            color: 'red',
          }}
          titleStyle={{ color: 'white' }}
          buttonStyle={styles.rejectButton}
          onPress={onReject}
        />
      </View>
    </View>
  );

  const friends = users[currentUserId]?.friends || {};
  const friendsList = Object.keys(friends).map(friendId => ({
    id: friendId,
    ...users[friendId]
  }));
  const friendRequests = users[currentUserId]?.requests || {};
  const pendingRequests = Object.entries(users).filter(([id, user]) => user.requests && user.requests[currentUserId]);

  return (
    <View style={styles.friendsPage}>
      <Header />
      <View style={styles.friendsHeader}>
        <Text style={styles.friendsTitle}>Friends</Text>
        <Button
          type="outline"
          icon={{
            name: 'user-plus',
            type: 'feather',
            size: 20,
            color: '#00ADB5',
          }}
          title="Add friend"
          buttonStyle={styles.addFriendButton}
          titleStyle={{ color: 'white' }}
          // onPress={() => { console.log('Add friend button pressed:', currentUserId); Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) }}
          onPress={() => {
            navigation.navigate('Map');
            focusSearchBar();
          }}
        />
      </View>
      <ScrollView style={styles.friendPageContainer}>
        {Object.entries(friendRequests).map(([id, _]) => (
          <FriendRequestCard
            key={id}
            username={users[id]?.name}
            onAccept={() => { acceptFriendRequest(id); Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) }}
            onReject={() => { rejectFriendRequest(id); Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) }}
          />
        ))}

        {friendsList.length === 0 ? (
          <Text style={styles.emptyFriendsText}>You sure seem lonely...</Text>
        ) : (
          friendsList.map((friend) => (
            <ListItem key={friend.id} style={styles.friendsList} containerStyle={styles.friendsListContainer} bottomDivider>
              <UserAvatarMarker user={{ name: friend.name }} color="#00ADB5" />
              <ListItem.Content>
                <ListItem.Title style={styles.friendsListText}>{friend.name}</ListItem.Title>
                <ListItem.Subtitle style={styles.friendsListText}>
                  {getDistanceFromLatLonInKm(
                    users[currentUserId].location.latitude,
                    users[currentUserId].location.longitude,
                    friend.location.latitude,
                    friend.location.longitude
                  ).toFixed(2)} km away
                </ListItem.Subtitle>
              </ListItem.Content>
              <Button
                type="clear"
                icon={{
                  name: 'dots-three-vertical',
                  type: 'entypo',
                  color: 'white',
                  size: 20,
                }}
                onPress={() => {
                  setDialogUser(friend);
                  setDialogVisible(true);
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                }}
              />
            </ListItem>
          ))
        )}

        {pendingRequests.length > 0 && (
          <>
            <Text style={styles.sectionTitle}>Pending Requests:</Text>
            {pendingRequests.map(([id, user]) => (
              <ListItem
                key={id}
                sytles={styles.friendsList}
                containerStyle={styles.friendsListContainer}
                bottomDivider
              // onPress={() => console.log('Pending request user pressed')}
              >
                <UserAvatarMarker user={user} size={30} color="gray" />
                <ListItem.Content>
                  <ListItem.Title style={styles.friendsPendingListText}>{user.name}</ListItem.Title>
                </ListItem.Content>
                <Button
                  type="clear"
                  icon={{
                    name: 'closecircleo',
                    type: 'antdesign',
                    color: 'gray',
                    size: 25,
                  }}
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); cancelPendingRequest(id); }}
                />
              </ListItem>
            ))}
          </>
        )}
      </ScrollView>
      <UserDialog
        isVisible={dialogVisible}
        onClose={() => setDialogVisible(false)}
        user={dialogUser}
      />
    </View>
  );
};

const YouScreen = () => {
  const { currentUserId, currentUserName, users, setCurrentUserName, setCurrentUserId, updateUser } = useUsers();
  const [name, setName] = useState(currentUserName);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  useEffect(() => {
    setName(currentUserName);
  }, [currentUserName]);

  const handleNameChange = (text) => {
    if (text.length <= 20) {
      setName(text);
      setHasUnsavedChanges(text !== currentUserName);
    }
  };

  const handleSave = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    if (currentUserId && name.trim()) {
      updateUser(currentUserId, { name: name.trim() });
      await AsyncStorage.setItem('userName', name.trim());
      setCurrentUserName(name.trim());
      setHasUnsavedChanges(false);
      Keyboard.dismiss();
    }
  };

  const handleCancel = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setName(currentUserName);
    setHasUnsavedChanges(false);
  };

  const handleDeleteAccount = async () => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    if (currentUserId) {
      try {
        const userRef = ref(database, `users/${currentUserId}`);

        for (let [userId, user] of Object.entries(users)) {
          if (userId === currentUserId) continue;

          const userFriendsRef = ref(database, `users/${userId}/friends/${currentUserId}`);
          const userRequestsRef = ref(database, `users/${userId}/requests/${currentUserId}`);
          await remove(userFriendsRef);
          await remove(userRequestsRef);
        }

        await remove(userRef);

        await AsyncStorage.clear();
        setCurrentUserName('');
        setCurrentUserId('');
      } catch (error) {
        console.error('Error deleting account:', error);
      }
    }
  };

  const numberOfFriends = users[currentUserId]?.friends ? Object.keys(users[currentUserId].friends).length : 0;

  return (
    <View style={styles.youPage}>
      <Header />
      <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
        <KeyboardAvoidingView style={{ flex: 1 }} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
          <View style={styles.youHeader}>
            <Text style={styles.youTitle}>My profile</Text>
          </View>
          <ScrollView contentContainerStyle={styles.youContainer}>
            <View style={styles.profileCard}>
              <Avatar
                size="large"
                rounded
                title={currentUserName.substring(0, 2).toUpperCase()}
                containerStyle={styles.profileAvatar}
                source={{ uri: "data:image/png" }}
              />
              <Text style={styles.profileName}>{currentUserName}</Text>
              <View style={styles.profileFriendsContainer}>
                <FontAwesome6 name="users" size={15} color="gray" />
                <Text style={styles.profileFriends}>
                  {numberOfFriends > 0 ? `${numberOfFriends} friend${numberOfFriends > 1 ? 's' : ''}` : 'lonely'}
                </Text>
              </View>
            </View>
            <Text style={styles.nameInputText}>Name:</Text>
            <TextInput
              style={styles.nameInput}
              value={name}
              onChangeText={handleNameChange}
              placeholder="Enter your name"
              placeholderTextColor="#CCCCCC"
              maxLength={20}
            />
            {hasUnsavedChanges && (
              <View style={styles.unsavedChangesContainer}>
                <TouchableOpacity onPress={handleSave} style={styles.saveButton}>
                  <Text style={styles.saveButtonText}>Save</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleCancel} style={styles.cancelButton}>
                  <Text style={styles.cancelButtonText}>Cancel</Text>
                </TouchableOpacity>
              </View>
            )}
            <View style={styles.hiddenSection}>
              <Text style={styles.uuidText}>ONLY TOUCH THIS IF YOU</Text>
              <Text style={styles.uuidText}>KNOW WHAT YOU ARE DOING</Text>
              <Text style={styles.uuidText}>Your UUID: {currentUserId}</Text>
              <TouchableOpacity
                onPress={handleDeleteAccount}
                style={styles.deleteButton}
              >
                <Text style={styles.deleteButtonText}>Delete Account</Text>
              </TouchableOpacity>
            </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </TouchableWithoutFeedback>
    </View>
  );
};

const App = () => {
  const [showOnboarding, setShowOnboarding] = useState(null);
  const { currentUserName, currentUserId, setCurrentUserName, setCurrentUserId } = useUsers();
  const searchBarRef = useRef(null);

  const focusSearchBar = () => {
    if (searchBarRef.current) {
      searchBarRef.current.focus();
    }
  };

  useEffect(() => {
    const checkUserData = async () => {
      try {
        const storedUserName = await AsyncStorage.getItem('userName');
        const storedUserId = await AsyncStorage.getItem('userId');
        if (storedUserId && storedUserName) {
          setCurrentUserId(storedUserId);
          setCurrentUserName(storedUserName);
          setShowOnboarding(false);
          await startLocationTracking();
        } else {
          setShowOnboarding(true);
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
      }
    };

    checkUserData();

    Notifications.requestPermissionsAsync();

    Notifications.setNotificationHandler({
      handleNotification: async () => ({
        shouldShowAlert: true,
        shouldPlaySound: false,
        shouldSetBadge: false,
      }),
    });

    // return () => {
    //   TaskManager.unregisterAllTasksAsync();
    // };
  }, []);

  const handleFinishOnboarding = (username, userId) => {
    // const userRef = ref(database, `users/${userId}`);
    // set(userRef, {
    //   id: userId,
    // });
    setCurrentUserName(username);
    setCurrentUserId(userId);
    setShowOnboarding(false);
  };

  if (showOnboarding) {
    return <OnboardingScreen onFinish={handleFinishOnboarding} />;
  }

  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={{
          headerShown: false,
          tabBarActiveTintColor: '#00ADB5',
          tabBarInactiveTintColor: '#EEEEEE',
          tabBarStyle: styles.bottomNavBar,
        }}
      >
        <Tab.Screen
          name="Map"
          options={{
            tabBarIcon: ({ color, size }) => (
              <FontAwesome6 name="earth-americas" size={size} color={color} />
            ),
          }}
        >
          {(props) => <MapScreen {...props} searchBarRef={searchBarRef} />}
        </Tab.Screen>
        <Tab.Screen
          name="Friends"
          options={{
            tabBarIcon: ({ color, size }) => (
              <FontAwesome6 name="users" size={size} color={color} />
            ),
          }}
        >
          {(props) => <FriendsScreen {...props} focusSearchBar={focusSearchBar} />}
        </Tab.Screen>
        <Tab.Screen
          name="You"
          component={YouScreen}
          options={{
            tabBarIcon: ({ color, size }) => (
              <UserAvatarMarker user={{ name: currentUserName }} size={size} />
            ),
          }}
        />
      </Tab.Navigator>
      <StatusBar barStyle="light-content" />
    </NavigationContainer>
  );
};

export default function Root() {
  return (
    <UsersProvider>
      <App />
    </UsersProvider>
  );
}

```

app.json
```json
{
  "expo": {
    "name": "Loco",
    "slug": "loco",
    "version": "0.1.2",
    "jsEngine": "hermes",
    "orientation": "portrait",
    "icon": "./assets/icon.jpg",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#212832"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.antoninbeliard.loco",
      "config": {
        "googleMapsApiKey": "AIzaSyB7NMaMY_YmXpY_pA6Xz0jfyB5J-xAodcI"
      },
      "infoPlist": {
        "UIBackgroundModes": [
          "location"
        ]
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#212832"
      },
      "icon": "./assets/icon.png",
      "package": "com.antoninbeliard.loco",
      "config": {
        "googleMaps": {
          "apiKey": "AIzaSyA7_2YtDt6Yj0H-ZlqYNZGM9qDYHY0O_c0"
        }
      },
      "permissions": [
        "ACCESS_COARSE_LOCATION",
        "ACCESS_FINE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "FOREGROUND_SERVICE",
        "FOREGROUND_SERVICE_LOCATION",
        "WAKE_LOCK"
      ],
      "softwareKeyboardLayoutMode": "pan",
      "manifest": {
        "service": [
          {
            "android:name": "com.antoninbeliard.loco.LocationService",
            "android:enabled": "true",
            "android:exported": "false",
            "android:foregroundServiceType": "location"
          }
        ]
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "eacea42d-f4e8-4a94-b43a-f19dc934865e"
      }
    },
    "owner": "totob12",
    "plugins": [
      "expo-router",
      "expo-asset",
      "expo-font",
      [
        "expo-location",
        {
          "locationAlwaysAndWhenInUsePermission": "Allow $(PRODUCT_NAME) to use your location."
        }
      ],
      "./configPlugins/withForegroundService.js"
    ]
  }
}
```

babel.config.js
```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};

```

configPlugins\withForegroundService.js
```javascript
const { AndroidConfig, withAndroidManifest } = require('@expo/config-plugins');
const path = require('path');
const fs = require('fs');

const withForegroundService = (config) => {
  return withAndroidManifest(config, async (config) => {
    const mainApplication = AndroidConfig.Manifest.getMainApplicationOrThrow(config.modResults);

    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'com.antoninbeliard.loco.foregroundservice.notification_channel_name',
      'Loco Service',
      'value',
    );
    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'com.antoninbeliard.loco.foregroundservice.notification_channel_description',
      'Loco Service running in the background.',
      'value',
    );
    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'com.antoninbeliard.loco.foregroundservice.notification_color',
      '@color/orange',
      'resource',
    );

    mainApplication.service = mainApplication.service || [];
    mainApplication.service.push({
      $: {
        'android:name': 'com.antoninbeliard.loco.LocationService',
        'android:enabled': 'true',
        'android:exported': 'false',
        'android:foregroundServiceType': 'location',
      },
    });
    mainApplication.service.push({
      $: {
        'android:name': 'com.antoninbeliard.loco.ForegroundService',
      },
    });
    mainApplication.service.push({
      $: {
        'android:name': 'com.antoninbeliard.loco.ForegroundServiceTask',
      },
    });

    const srcFilePath = path.join(__dirname, 'color.xml');
    const resFilePath = path.join(
      await AndroidConfig.Paths.getResourceFolderAsync(config.modRequest.projectRoot),
      'values',
      'color.xml',
    );

    const resDir = path.resolve(resFilePath, '..');
    if (!fs.existsSync(resDir)) {
      await fs.promises.mkdir(resDir);
    }

    try {
      await fs.promises.copyFile(srcFilePath, resFilePath);
    } catch (e) {
      throw e;
    }

    return config;
  });
};

module.exports = withForegroundService;

```

eas.json
```json
{
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "preview2": {
      "android": {
        "gradleCommand": ":app:assembleRelease"
      }
    },
    "preview3": {
      "developmentClient": true
    },
    "preview4": {
      "distribution": "internal"
    },
    "production": {
      "android": {
        "buildType": "apk"
      }
    }
  }
}

```

firebaseConfig.js
```javascript
export const firebaseConfig = {
    apiKey: "AIzaSyC_TXnoiNb8Q0fCN5PiRiXMxryP-4nBkbk",
    authDomain: "loco-totob12.firebaseapp.com",
    databaseURL: "https://loco-totob12-default-rtdb.firebaseio.com",
    projectId: "loco-totob12",
    storageBucket: "loco-totob12.appspot.com",
    messagingSenderId: "252756761693",
    appId: "1:252756761693:web:c58400b90a4365c97101b4",
};

```

generateUsername.js
```javascript
"use strict";

const { nouns, adjectives } = require("./usernameDict");

const getRandomInt = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

const randomNumber = (maxNumber) => {
    if (maxNumber < 1 || !Number.isFinite(maxNumber)) {
        return "";
    }

    let min = Math.pow(10, maxNumber - 1);
    let max = Math.pow(10, maxNumber) - 1;

    return getRandomInt(min, max).toString();
};

function generateUsername(separator = "", randomDigits = 0, length = undefined, prefix = "") {
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    const adjective = prefix ? prefix.trim().replace(/\s+/g, separator).toLowerCase() : adjectives[Math.floor(Math.random() * adjectives.length)];
    let username;

    if (separator) {
        username = adjective + separator + noun + randomNumber(randomDigits);
    } else {
        username = adjective + noun + randomNumber(randomDigits);
    }

    if (length) {
        username = username.substring(0, length);
    }

    return username;
}

module.exports = { generateUsername };

```

locationTask.js
```javascript
import * as TaskManager from 'expo-task-manager';
import * as Location from 'expo-location';
import { getDatabase, ref, update } from 'firebase/database';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const LOCATION_TASK_NAME = 'background-location-task';

TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error(error);
    return;
  }
  if (data) {
    const { locations } = data;
    const database = getDatabase();
    const userId = await AsyncStorage.getItem('userId');
    const userName = await AsyncStorage.getItem('userName');
    if (userId && userName && locations && locations.length > 0) {
      const { latitude, longitude } = locations[0].coords;
      const userRef = ref(database, `users/${userId}`);
      await update(userRef, {
        location: locations[0].coords,
        timestamp: Date.now(),
      });
    }
  }
});

export const startLocationTracking = async () => {
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus !== 'granted') {
    console.error('Foreground location permission is required');
    return;
  }

  const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
  if (backgroundStatus !== 'granted') {
    console.error('Background location permission is required');
    return;
  }

  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.High,
    distanceInterval: 1,
    deferredUpdatesInterval: 1000,
    foregroundService: {
      notificationTitle: "Location tracking",
      notificationBody: "Location tracking is running",
      notificationColor: "#00ADB5",
    },
    pausesUpdatesAutomatically: false,
  });
};
```

ModalScreen.js
```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const ModalScreen = ({ navigation }) => {
  return (
    <View style={styles.centeredView}>
      <Text style={styles.modalText}>Hello World</Text>
      <Button title="Dismiss" onPress={() => navigation.goBack()} />
    </View>
  );
};

const styles = StyleSheet.create({
  centeredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 22
  },
  modalText: {
    marginBottom: 15,
    textAlign: "center"
  }
});

export default ModalScreen;

```

OnboardingScreen.js
```javascript
// OnboardingScreen.js
import React, { useState, useRef } from 'react';
import { View, Text, TouchableOpacity, TextInput } from 'react-native';
import ViewPager from '@react-native-community/viewpager';
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { generateUsername } from './generateUsername';
import { generateUuidAndSave } from './App';
import { styles } from './Styles';

function OnboardingScreen({ onFinish }) {
  const pagerRef = useRef(null);
  const [username, setUsername] = useState(generateUsername("-", 3));

  return (
    <ViewPager style={{ flex: 1 }} ref={pagerRef}>
      <View key="1" style={styles.page}>
        <Text style={styles.title}>Welcome to Loco</Text>
        <FontAwesome6 name="earth-americas" size={100} color="white" />
        <TouchableOpacity onPress={() => pagerRef.current.setPage(1)} style={styles.button}>
          <Text style={styles.buttonText}>Next</Text>
        </TouchableOpacity>
      </View>
      <View key="2" style={[styles.page, { backgroundColor: '#07689f' }]}>
        <Text style={styles.title}>Choose Your Name</Text>
        <TextInput
          style={styles.input}
          onChangeText={setUsername}
          value={username}
          placeholder="Enter your username"
        />
        <TouchableOpacity onPress={() => pagerRef.current.setPage(2)} style={styles.button}>
          <Text style={styles.buttonText}>Save</Text>
        </TouchableOpacity>
      </View>
      <View key="3" style={[styles.page, { backgroundColor: '#eb8f8f' }]}>
        <Text style={styles.title}>Finish Setup</Text>
        <FontAwesome6 name="globe" size={100} color="white" />
        <TouchableOpacity onPress={async () => {
          const userId = await generateUuidAndSave();
          await AsyncStorage.setItem('userName', username);
          onFinish(username, userId);
        }} style={styles.button}>
          <Text style={styles.buttonText}>Finish Setup</Text>
        </TouchableOpacity>
      </View>
    </ViewPager>
  );
}

export default OnboardingScreen;

```

package.json
```json
{
  "name": "loco",
  "version": "0.1.0",
  "scripts": {
    "start": "npx expo start --dev-client",
    "android": "npx expo run:android",
    "ios": "npx expo run:ios",
    "web": "npx expo start --web"
  },
  "dependencies": {
    "@expo/metro-runtime": "~3.2.1",
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/geolocation": "^3.2.1",
    "@react-native-community/viewpager": "5.0.11",
    "@react-navigation/bottom-tabs": "^6.5.20",
    "@react-navigation/native": "^6.1.17",
    "@react-navigation/native-stack": "^6.9.26",
    "@react-navigation/stack": "^6.3.29",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "expo": "~51.0.8",
    "expo-asset": "~10.0.6",
    "expo-background-fetch": "~12.0.1",
    "expo-clipboard": "~6.0.3",
    "expo-dev-client": "~4.0.14",
    "expo-haptics": "~13.0.1",
    "expo-location": "~17.0.1",
    "expo-notifications": "^0.28.9",
    "expo-router": "~3.5.14",
    "expo-status-bar": "~1.12.1",
    "expo-task-manager": "~11.8.1",
    "firebase": "^10.12.0",
    "moment": "^2.30.1",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-native": "0.74.1",
    "react-native-gesture-handler": "~2.16.2",
    "react-native-get-random-values": "~1.11.0",
    "react-native-maps": "1.15.6",
    "react-native-safe-area-context": "^4.10.1",
    "react-native-screens": "^3.31.1",
    "react-native-web": "~0.19.11",
    "socket.io-client": "^4.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.24.5"
  },
  "private": true
}

```

Styles.js
```javascript
import { StyleSheet } from 'react-native';

// https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY&center=47.63562994735659,-122.42192478329498&zoom=12&format=png&maptype=roadmap&style=element:geometry%7Ccolor:0x242f3e&style=element:labels.icon%7Cvisibility:off&style=element:labels.text.fill%7Ccolor:0x746855&style=element:labels.text.stroke%7Ccolor:0x242f3e&style=feature:administrative.locality%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:poi.park%7Celement:geometry%7Ccolor:0x263c3f&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x6b9a76&style=feature:road%7Celement:geometry%7Ccolor:0x38414e&style=feature:road%7Celement:geometry.stroke%7Ccolor:0x212a37&style=feature:road%7Celement:labels.text.fill%7Ccolor:0x9ca5b3&style=feature:road.highway%7Celement:geometry%7Ccolor:0x746855&style=feature:road.highway%7Celement:geometry.stroke%7Ccolor:0x1f2835&style=feature:road.highway%7Celement:labels.text.fill%7Ccolor:0xf3d19c&style=feature:transit%7Celement:geometry%7Ccolor:0x2f3948&style=feature:transit.station%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:water%7Celement:geometry%7Ccolor:0x17263c&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x515c6d&style=feature:water%7Celement:labels.text.stroke%7Ccolor:0x17263c&size=480x360

export const customMapStyle = [
  {
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#242f3e"
      }
    ]
  },
  {
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#746855"
      }
    ]
  },
  {
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#242f3e"
      }
    ]
  },
  {
    "featureType": "administrative.locality",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#d59563"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#d59563"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#263c3f"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#6b9a76"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#38414e"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "color": "#212a37"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9ca5b3"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#746855"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "color": "#1f2835"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#f3d19c"
      }
    ]
  },
  {
    "featureType": "transit",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#2f3948"
      }
    ]
  },
  {
    "featureType": "transit.station",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#d59563"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#17263c"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#515c6d"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#17263c"
      }
    ]
  }
];

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#222831',
  },
  map: {
    flex: 1,
    // height: '110%',
  },
  topBar: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 8,
    backgroundColor: '#393E46',
  },
  appName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#EEEEEE',
  },
  settingsContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#222831',
  },
  settingsTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#EEEEEE',
  },
  // bottomNavBar: {
  //   flexDirection: 'row',
  //   justifyContent: 'space-around',
  //   alignItems: 'center',
  //   paddingVertical: 8,
  //   backgroundColor: '#393E46',
  // },
  bottomNavBar: {
    backgroundColor: '#393E46',
    height: 85,
  },
  navButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
    backgroundColor: '#222831',
  },
  activeNavButton: {
    backgroundColor: '#00ADB5',
  },
  navButtonText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#EEEEEE',
  },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#222831',
  },
  saveButton: {
    backgroundColor: '#00ADB5',
    padding: 10,
    borderRadius: 5,
    marginTop: 10,
  },
  saveButtonText: {
    color: 'white',
    fontSize: 16,
    textAlign: 'center',
  },
  userIcon: {
    width: 30,
    height: 30,
    borderRadius: 15,
  },
  filterContainer: {
    flexDirection: 'row',
    alignItems: 'center', // Added to align items horizontally
    position: 'absolute',
    zIndex: 9999,
    top: 10,
    width: '100%',
  },
  closeButtonStyle: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    height: 50,
    width: 50,
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButtonContainer: {
    marginLeft: 10,
  },
  searchContainerStyle: {
    marginTop: 50,
    left: 10,
    right: 10,
    height: 50,
    backgroundColor: '#FFFFFF',
    borderTopColor: '#FFFFFF',
    borderBottomColor: '#FFFFFF',
    borderRadius: 12,
    position: 'absolute',
  },
  searchInputContainerStyle: {
    height: '100%',
    backgroundColor: '#FFFFFF',
  },
  searchInputStyle: {
    fontSize: 16,
  },
  searchResultsContainer: {
    position: 'absolute',
    top: 120,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 99999,
    backgroundColor: 'white'
  },
  noUserFoundContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noUserFoundText: {
    fontSize: 20,
    color: 'gray',
  },
  chipsContainer: {
    flexDirection: 'row',
    // justifyContent: 'center',
    left: 10,
    marginTop: 110,
    // marginBottom: 10,
  },
  chipContainerStyle: {
    marginHorizontal: 5,
    // backgroundColor: '#FFFFFF',
  },
  chipStyle: {
    height: 36,
    backgroundColor: '#FFFFFF',
    // color: '#222831',
  },
  selectedChipStyle: {
    backgroundColor: '#9d9d9d',
  },
  recenterButton: {
    backgroundColor: '#FFFFFF',
    width: 50,
    height: 50,
    borderRadius: 12,
  },
trackingButton: {
  backgroundColor: '#00ADB5', // #FF6347
  width: 50,
  height: 50,
  borderRadius: 12,
},
  recenterButtonContainer: {
    position: 'absolute',
    bottom: 20,
    right: 20,
  },
  page: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ffc93c'
  },
  title: {
    fontSize: 22,
    color: 'white',
    marginBottom: 20
  },
  button: {
    marginTop: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    backgroundColor: 'white',
    borderRadius: 5
  },
  buttonText: {
    fontSize: 18,
    color: '#07689f'
  },
  headerContainer: {
    backgroundColor: '#222831',
    // paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
  },
  friendsPage: {
    flex: 1,
    backgroundColor: '#222831',
    padding: 10,
  },
  friendsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 10,
    // backgroundColor: '#393E46',
  },
  friendsTitle: {
    fontSize: 30,
    fontWeight: 'bold',
    color: '#EEEEEE',
  },
  addFriendButton: {
    // backgroundColor: '#00ADB5',
    borderColor: 'gray',
    borderRadius: 5,
    borderWidth: 1.5,
  },
  friendPageContainer: {
    padding: 10,
  },
  sectionTitle: {
    fontSize: 25,
    fontWeight: 'bold',
    color: '#EEEEEE',
    paddingTop: 30,
    paddingBottom: 10,
  },
  friendRequestCard: {
    backgroundColor: '#2b3543',
    // marginBottom: 10,
    padding: 20,
    borderRadius: 7,
  },
  friendRequestHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
  },
  friendRequestIcon: {
    marginRight: 10,
    marginLeft: 10,
  },
  friendRequestText: {
    flex: 1,
    color: 'white',
    fontSize: 18,
  },
  friendRequestUsernameText: {
    // flex: 1,
    color: '#00ADB5', // "#00ADB5
    fontSize: 18,
  },
  friendRequestActions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  acceptButton: {
    // backgroundColor: 'green',
    borderColor: 'green',
    borderWidth: 1.5,
    borderRadius: 5,
  },
  rejectButton: {
    // backgroundColor: 'red',
    borderColor: 'red',
    borderWidth: 1.5,
    borderRadius: 5,
  },
  userDetailCard: {
    position: 'absolute',
    bottom: 100,
    left: 20,
    right: 20,
    padding: 20,
    backgroundColor: '#FFFFFF',
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.8,
    shadowRadius: 2,
    elevation: 5,
  },
  userDetailName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  userDetailDistance: {
    fontSize: 16,
    marginTop: 5,
  },
  userDetailTimestamp: {
    fontSize: 14,
    color: 'gray',
    marginTop: 5,
  },
  closeButton: {
    marginTop: 10,
    backgroundColor: '#00ADB5',
  },
  card: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    padding: 10,
    borderRadius: 8,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowRadius: 5,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
    width: 200,
  },
  avatar: {
    backgroundColor: '#00ADB5',
  },
  userOptions: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  info: {
    flex: 1,
    marginLeft: 10,
  },
  name: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  details: {
    fontSize: 14,
    color: '#555',
  },
  centeredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 22,
  },
  modalView: {
    margin: 20,
    backgroundColor: 'white',
    borderRadius: 7,
    padding: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  button: {
    borderRadius: 20,
    padding: 10,
    elevation: 2,
  },
  buttonOpen: {
    backgroundColor: '#F194FF',
  },
  buttonClose: {
    backgroundColor: '#2196F3',
  },
  textStyle: {
    color: 'white',
    fontWeight: 'bold',
    textAlign: 'center',
  },
  modalText: {
    margin: 15,
    textAlign: 'center',
  },
  dialogButton: {
    backgroundColor: 'white',
    marginVertical: 5,
    width: '100%',
  },
  dialogButtonTitle: {
    color: 'black',
  },
  emptyFriendsText: {
    textAlign: 'center',
    color: '#EEEEEE',
    marginTop: 20,
    fontSize: 20,
  },
  friendsList: {
    
  },
  friendsListContainer: {
    backgroundColor: 'none',
  },
  friendsListText: {
    color: 'white',
  },
  friendsPendingListText: {
    color: 'gray',
  },
  youPage: {
    flex: 1,
    backgroundColor: '#222831',
    // padding: 10,
  },
  youContainer: {
    flexGrow: 1,
    backgroundColor: '#222831',
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 100,
  },
  youHeader: {
    width: '100%',
    paddingHorizontal: 20,
  },
  youTitle: {
    fontSize: 30,
    fontWeight: 'bold',
    color: '#EEEEEE',
    marginBottom: 20,
    marginTop: 15,
  },
  profileCard: {
    backgroundColor: '#2b3543',
    padding: 20,
    borderRadius: 7,
    alignItems: 'center',
    marginBottom: 20,
    width: '90%',
  },
  profileAvatar: {
    backgroundColor: '#00ADB5',
    marginBottom: 22,
  },
  profileName: {
    color: '#EEEEEE',
    fontSize: 27,
    marginBottom: 5,
  },
  profileFriendsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  profileFriends: {
    color: 'gray',
    fontSize: 16,
    marginLeft: 5,
  },
  nameInputText: {
    color: '#EEEEEE',
    fontSize: 16,
    left: 20,
    alignSelf: 'flex-start',
    marginBottom: 10,
    marginTop: 12,
  },
  nameInput: {
    height: 60,
    width: '90%',
    fontSize: 17,
    borderWidth: 1,
    borderColor: '#00ADB5',
    borderRadius: 7,
    paddingHorizontal: 8,
    color: '#EEEEEE',
    backgroundColor: '#393E46',
    marginBottom: 10,
  },
  unsavedChangesContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '80%',
    marginBottom: 20,
  },
  saveButton: {
    backgroundColor: '#00ADB5',
    padding: 10,
    borderRadius: 5,
    marginRight: 10,
  },
  saveButtonText: {
    color: 'white',
    fontSize: 16,
  },
  cancelButton: {
    backgroundColor: '#393E46',
    padding: 10,
    borderRadius: 5,
  },
  cancelButtonText: {
    color: 'white',
    fontSize: 16,
  },
  uuidText: {
    fontSize: 16,
    color: '#EEEEEE',
    // paddingTop: 200,
    marginBottom: 10,
  },
  hiddenSection: {
    marginTop: 300,
  },
  deleteButton: {
    backgroundColor: '#D9534F',
    padding: 10,
    borderRadius: 5,
  },
  deleteButtonText: {
    color: 'white',
    fontSize: 16,
    textAlign: 'center',
  },
  onboardingPage: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#222831',
  },
  onboardingTitle: {
    fontSize: 22,
    color: '#EEEEEE',
    marginBottom: 20,
  },
  onboardingInput: {
    height: 40,
    width: '80%',
    borderWidth: 1,
    borderColor: '#00ADB5',
    borderRadius: 4,
    paddingHorizontal: 8,
    color: '#EEEEEE',
    backgroundColor: '#393E46',
    marginBottom: 16,
  },
  onboardingButton: {
    backgroundColor: '#00ADB5',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 5,
    marginTop: 20,
  },
  onboardingButtonText: {
    fontSize: 18,
    color: 'white',
    textAlign: 'center',
  },
});

```

tsconfig.json
```json
{
  "compilerOptions": {},
  "extends": "expo/tsconfig.base"
}

```

What I am trying to make is a simple and elegant location sharing app, where users can see the live location of all of their friends in real-time. But before that, the account creation process needs to be fully changed. I want the app to use Firebase Authentication to create and manage account. During the onboarding process, the app should also request an email, and then a password (have it be entered twice to check, on the same page). The last page should be the password one, and the button should be a "Sign Up" button. When clicked, the account should be created using Firebase Authenticator, and the user information should be saved in the Realtime Database.
Before the Onboarding screen, the first screen users should see it a simple page with the Loco logo, and two buttons: "Sign Up" and "Login". The login screen should be extremely simple, with just an email and password field.
I want you to fully develop and implement this. Make sure to develop all needed features and changes needed for this to function properly.